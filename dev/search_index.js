var documenterSearchIndex = {"docs":
[{"location":"#ModelingToolkitInputs.jl","page":"Home","title":"ModelingToolkitInputs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkitInputs.jl provides support for driving ModelingToolkit model inputs with data in determinate (data known upfront) and indeterminate form (data streamed at runtime).","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"ModelingToolkitInputs\")","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In ModelingToolkit it is possible to mark a variable as an input, as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"@variables x(t) [input=true]","category":"page"},{"location":"","page":"Home","title":"Home","text":"When compiling the model using mtkcompile, if the input variable is not connected to a source, then it must be specified with the inputs keyword.  When this is done, ModelingToolkit will convert the variable to a \"discrete variable\".  In ModelingToolkit a discrete variable is technically a parameter that has an independant variable.  So for example one can create a discrete variable as follows","category":"page"},{"location":"","page":"Home","title":"Home","text":"@parameters x(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In ModelingToolkitInputs a new system type InputSystem is provided that adds the functions necessary (input_functions) to feed data into these discrete input variables. The input_functions are generated when calling mtkcompile on an InputSystem, as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing ModelingToolkitInputs\n\n# Define system with an input variable\n@variables x(t) [input=true]\n@variables y(t) = 0\n\neqs = [D(y) ~ x]\n\n# Compile with inputs specified\n@mtkcompile sys=InputSystem(eqs, t, [x, y], []) inputs=[x]","category":"page"},{"location":"","page":"Home","title":"Home","text":"As can be seen this system has 2 variables and 1 equation. By telling ModelingToolkit that x is an input, the system is then balanced because a connection with x is now assumed.  The input_functions which are generated enable that assumed connection to a data source.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: when the System is defined in a function, it can be converted to an InputSystem as follows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"function Demo(;name)\n    @variables x(t) [input=true]\n    @variables y(t) = 0\n\n    eqs = [D(y) ~ x]\n\n    return System(eqs, t, [x, y], []; name)\nend\n\n@named demo = Demo()\n@mtkcompile sys=InputSystem(demo) inputs=ModelingToolkit.unbound_inputs(demo)","category":"page"},{"location":"#Indeterminate-Form:-Using-ModelingToolkit-with-Streaming-Data","page":"Home","title":"Indeterminate Form: Using ModelingToolkit with Streaming Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When input values need to be computed on-the-fly or depend on external data sources, you can manually set inputs while steping the integrator using set_input!.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OrdinaryDiffEq\nusing Plots\n\nprob = ODEProblem(sys, [], (0, 4))\n\n# Initialize the integrator\nintegrator = init(prob, Tsit5())\n\n# Manually set inputs and step through time\ndt = 1.0\nfor i=1:4\n    # input streaming data\n    set_input!(integrator, sys.x, i)\n\n    # step the model forward in time\n    step!(integrator, dt, true)\n\n    # (optional) compute something with outputs...\n    println(\"y=$(integrator[y])\")\nend\n\nfinalize!(integrator)\n\nplot(integrator.sol; idxs = [x, y])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: here we can see that x initializes at a value of 0.0, which is the assumed initial value if no default value is given in the model.  As can be seen, this is no concequence as the value changes immediately at time 0 to the set value of 1.0 before steping the integrator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Always call `finalize!`\nWhen using set_input!, you must call finalize! after integration is complete. This ensures that all discrete callbacks associated with input variables are properly saved in the solution. Without this call, input values may not be correctly recorded when querying the solution.","category":"page"},{"location":"#Determinate-Form:-Connecting-ModelingToolkit-inputs-to-Data","page":"Home","title":"Determinate Form: Connecting ModelingToolkit inputs to Data","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When data is available, you can use the Input type to specify input values at specific time points. The solver will automatically apply these values using discrete callbacks.  Then supply a vector of Input's using the inputs keyword to solve.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Create an Input object with predetermined values\ninput = Input(sys.x, [1, 2, 3, 4], [0, 1, 2, 3])\n\nsol = solve(prob, Tsit5(); inputs=[input])\n\nplot(sol; idxs = [x, y])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Multiple Input objects can be passed in a vector to handle multiple input variables simultaneously.","category":"page"},{"location":"#Benefits-of-ModelingToolkitInputs-vs.-DataInterpolations","page":"Home","title":"Benefits of ModelingToolkitInputs vs. DataInterpolations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are several reasons why one would want to input data into their model using ModelingToolkitInputs:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The same System (or InputSystem) can be used in both determinate and indeterminate forms without requiring any changes or modifications to the system.  This makes it very convenient to use and test the system against previously recorded data and be sure the exact same system will work in practice/deployment with streaming data.\nRunning several large datasets using ModelingToolkitInputs requires only 1 step: (1) call solve with each dataset.  When the data is included in the system using an interpolation object, this requires 2 steps: (1) remake the problem with new data, (2) then call solve.  \nThe 2 step process described above is significantly slower than the single step solve with ModelingToolkitInputs\nFinally using Interpolation requires that the data length be a constant for all datasets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following example demonstrates this comparison.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ModelingToolkit\nusing ModelingToolkit: t_nounits as t, D_nounits as D\nusing ModelingToolkitInputs\nusing ModelingToolkitStandardLibrary.Blocks\nusing DataInterpolations\nusing OrdinaryDiffEq\nusing Plots\n\nfunction MassSpringDamper(; name)\n    vars = @variables begin\n        f(t), [input = true] \n        x(t)=0 \n        dx(t)=0\n        ddx(t)\n    end\n    pars = @parameters m=10 k=1000 d=1\n\n    eqs = [ddx * 10 ~ k * x + d * dx + f\n           D(x) ~ dx\n           D(dx) ~ ddx\n           ]\n\n    return System(eqs, t, vars, pars; name)\nend\n\nfunction MassSpringDamperSystem(data, time; name)\n    @named src = ParametrizedInterpolation(ConstantInterpolation, data, time)\n    @named clk = ContinuousClock()\n    @named model = MassSpringDamper()\n\n    eqs = [model.f ~ src.output.u\n           connect(clk.output, src.input)]\n\n    return System(eqs, t; name, systems = [src, clk, model])\nend\n\ndt = 4e-4\ntime = collect(0:dt:0.1)\ndata = 2 .* sin.(2 * pi * time * 100)\n\n@mtkcompile sys = MassSpringDamperSystem(data, time)\nprob = ODEProblem(sys, [], (0, time[end]))\nsol1 = solve(prob)\nplot(sol1; idxs=sys.model.dx)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now let's record how much time it takes to replace the data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BenchmarkTools\ndata2 = 100 .* one.(data)\nsol2 = @btime begin \n    prob2 = remake(prob, p = [sys.src.data => data2])\n    solve(prob2)\nend\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"As can be seen, this takes over 400ms to run a new dataset.  In comparison using ModelingToolkitInputs only takes just over 1ms for each dataset run.  Additionally note, we can run the MassSpringDamper component directly without needing to wrap it in another component, making it very simple to run in determiniate or indeterminate forms.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"@named sysi = MassSpringDamper()\ninputs=ModelingToolkit.unbound_inputs(sysi); #f\nsysi = mtkcompile(InputSystem(sysi); inputs)\nprobi = ODEProblem(sysi, [], (0, time[end]))\n\nsol1i = @btime begin \n    in1 = Input(sysi.f, data, time)\n    solve(probi; inputs=[in1])\nend\nsol2i = @btime begin \n    in2 = Input(sysi.f, data2, time)\n    solve(probi; inputs=[in2])\nend\nnothing # hide","category":"page"},{"location":"#Discontinuities","page":"Home","title":"Discontinuities","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One important detail to point out is that the input is discontinuous.  Note that the interpolation type set is ConstantInterpolation to provide the true form of the data input.  In order to properly numerically solve this, the solver needs to know when these discontinuites occur.  Currently this is not automatically provided by ModelingToolkit interpolation, and it hasn't been added manually in this comparison.  As a result the DataInterpolations solution is done in 122 steps.  The use of ModelingToolkitInputs however does provide the correct solving for discontinuities becuase the use of DiscreteCallbacks is used at each discrete data input time.  Therefore the solution is given in n=2*length(time) because a solve is done on each side of the discrete steps.  The difference in solution quality can be seen when comparing sol1 and sol1i where the input force is a sine wave.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"plot(sol1.t, sol1[sys.model.dx]; marker=:dot, label=\"MTK + Interpolation (n=$(length(sol1.t)))\")\nplot!(sol1i.t, sol1i[sysi.dx]; marker=:+, label=\"ModelingToolkitInputs (n=$(length(sol1i.t)))\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Therefore the end result is ModelingToolkitInputs offers a faster, more convenient way to provide data input with a higher accuracy solution provided automatically.  ","category":"page"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#ModelingToolkitInputs.Input","page":"Home","title":"ModelingToolkitInputs.Input","text":"Input(var, data, time)\n\nType used to provide data input for a InputSystem\n\n\n\n\n\n","category":"type"},{"location":"#ModelingToolkitInputs.InputSystem","page":"Home","title":"ModelingToolkitInputs.InputSystem","text":"InputSystem(sys::ModelingToolkit.System)\nInputSystem(eqs, args...; kwargs...)\n\nWraps a ModelingToolkit.System object to provide the functions to feed data to discrete variables.  Generate an InputSystem either directly in place of a System or by wrapping an already generate system.\n\n\n\n\n\n","category":"type"},{"location":"#ModelingToolkitInputs.set_input!","page":"Home","title":"ModelingToolkitInputs.set_input!","text":"set_input!(input_integrator::InputIntegrator, var, value::Real)\n\nSets the value of a discrete variable of a ModelingToolkit input.  For example\n\nset_input!(integrator, sys.x, 1.0)\nstep!(integrator, dt)\n\n\n\n\n\n","category":"function"},{"location":"#ModelingToolkitInputs.finalize!","page":"Home","title":"ModelingToolkitInputs.finalize!","text":"finalize!(input_integrator::InputIntegrator)\n\nSaves the final state of all discrete variables.  Call after the final step of the integrator.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"In addition, the keyword inputs is added to solve.  ","category":"page"}]
}
